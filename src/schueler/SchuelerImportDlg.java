/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * SchuelerImportDlg.java
 *
 * Created on 02.09.2011, 10:34:18
 */
package schueler;

import java.awt.Font;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.swing.GroupLayout;
import javax.swing.GroupLayout.Alignment;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.LayoutStyle.ComponentPlacement;
import javax.swing.filechooser.FileNameExtensionFilter;

import org.jdesktop.application.Action;
import org.jdesktop.application.Application;
import org.jdesktop.application.ResourceMap;
import org.jdesktop.application.Task;
import org.jdesktop.application.TaskEvent;
import org.jdesktop.application.TaskListener;

import schliessfach.SchliessfachApp;
import schliessfach.SchliessfachView;
import vertrag.Vertrag;
import vertrag.Zahlungsart;

/**
 * 
 * @author fschuett
 */
@SuppressWarnings("serial")
public class SchuelerImportDlg extends javax.swing.JDialog {

	private EntityManager em;
	private Map<Long, Schueler> schuelerMap;
	private Vector<Long> bearbeitet;
	private boolean importInArbeit;
	private ResourceMap resourceMap;
	private static final File STANDARDDIR = new File(
			"G:\\School\\Export zu GHSchließfach");

	/** Creates new form SchuelerImportDlg */
	public SchuelerImportDlg(java.awt.Frame parent) {
		super(parent, true);
		em = SchliessfachApp.getApplication().em;
		Query q = em
				.createQuery("SELECT s.nr,s FROM Schueler s ORDER BY s.nr ASC");
		schuelerMap = new HashMap<Long, Schueler>();
		for (Object[] o : (List<Object[]>) q.getResultList()) {
			schuelerMap.put((Long) o[0], (Schueler) o[1]);
		}
		bearbeitet = new Vector<Long>(schuelerMap.size());
		importInArbeit = false;
		initComponents();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		jPanel1 = new javax.swing.JPanel();
		dateiName = new javax.swing.JTextField();
		waehle = new javax.swing.JButton();
		jPanel2 = new javax.swing.JPanel();
		importiere = new javax.swing.JButton();
		jbSchliessen = new javax.swing.JButton();
		jbHilfe = new javax.swing.JButton();
		jPanel3 = new javax.swing.JPanel();
		jScrollPane1 = new javax.swing.JScrollPane();
		protokoll = new javax.swing.JTextArea();
		jPanel4 = new javax.swing.JPanel();
		cbTestLauf = new javax.swing.JCheckBox();

		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
		resourceMap = org.jdesktop.application.Application
				.getInstance(schliessfach.SchliessfachApp.class).getContext()
				.getResourceMap(SchuelerImportDlg.class);
		setTitle(resourceMap.getString("Form.title")); // NOI18N
		setName("Form"); // NOI18N
		addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent evt) {
				formWindowClosing(evt);
			}
		});

		jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null,
				resourceMap.getString("jPanel1.border.title"),
				javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
				javax.swing.border.TitledBorder.DEFAULT_POSITION,
				resourceMap.getFont("jPanel1.border.titleFont"))); // NOI18N
		jPanel1.setName("jPanel1"); // NOI18N

		dateiName.setText(resourceMap.getString("dateiName.text")); // NOI18N
		dateiName.setName("dateiName"); // NOI18N

		waehle.setFont(resourceMap.getFont("waehle.font")); // NOI18N
		waehle.setText("Durchsuchen..."); // NOI18N
		waehle.setName("waehle"); // NOI18N
		waehle.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				waehleActionPerformed(evt);
			}
		});

		JLabel lblZeichensatz = new JLabel("Zeichensatz:");
		lblZeichensatz.setFont(new Font("Dialog", Font.PLAIN, 12));

		zeichensatz = new JComboBox(Charset.availableCharsets().keySet()
				.toArray());
		zeichensatz.setFont(new Font("Dialog", Font.PLAIN, 12));
		zeichensatz.setSelectedItem("windows-1252");

		javax.swing.GroupLayout gl_jPanel1 = new javax.swing.GroupLayout(
				jPanel1);
		gl_jPanel1
				.setHorizontalGroup(gl_jPanel1
						.createParallelGroup(Alignment.TRAILING)
						.addGroup(
								Alignment.LEADING,
								gl_jPanel1
										.createSequentialGroup()
										.addContainerGap()
										.addGroup(
												gl_jPanel1
														.createParallelGroup(
																Alignment.LEADING)
														.addGroup(
																gl_jPanel1
																		.createSequentialGroup()
																		.addComponent(
																				lblZeichensatz,
																				GroupLayout.PREFERRED_SIZE,
																				81,
																				GroupLayout.PREFERRED_SIZE)
																		.addGap(2)
																		.addComponent(
																				zeichensatz,
																				GroupLayout.PREFERRED_SIZE,
																				156,
																				GroupLayout.PREFERRED_SIZE))
														.addGroup(
																gl_jPanel1
																		.createSequentialGroup()
																		.addComponent(
																				dateiName,
																				GroupLayout.DEFAULT_SIZE,
																				416,
																				Short.MAX_VALUE)
																		.addGap(18)
																		.addComponent(
																				waehle,
																				GroupLayout.PREFERRED_SIZE,
																				120,
																				GroupLayout.PREFERRED_SIZE)))
										.addContainerGap()));
		gl_jPanel1
				.setVerticalGroup(gl_jPanel1
						.createParallelGroup(Alignment.LEADING)
						.addGroup(
								gl_jPanel1
										.createSequentialGroup()
										.addGroup(
												gl_jPanel1
														.createParallelGroup(
																Alignment.BASELINE)
														.addComponent(
																dateiName,
																GroupLayout.PREFERRED_SIZE,
																GroupLayout.DEFAULT_SIZE,
																GroupLayout.PREFERRED_SIZE)
														.addComponent(waehle))
										.addPreferredGap(
												ComponentPlacement.UNRELATED)
										.addGroup(
												gl_jPanel1
														.createParallelGroup(
																Alignment.BASELINE)
														.addComponent(
																lblZeichensatz)
														.addComponent(
																zeichensatz,
																GroupLayout.PREFERRED_SIZE,
																GroupLayout.DEFAULT_SIZE,
																GroupLayout.PREFERRED_SIZE))
										.addContainerGap(32, Short.MAX_VALUE)));
		jPanel1.setLayout(gl_jPanel1);

		jPanel2.setName("jPanel2"); // NOI18N

		importiere.setFont(resourceMap.getFont("importiere.font")); // NOI18N
		importiere.setText(resourceMap.getString("importiere.text")); // NOI18N
		importiere.setName("importiere"); // NOI18N
		importiere.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				importiereActionPerformed(evt);
			}
		});

		jbSchliessen.setFont(resourceMap.getFont("jbSchliessen.font")); // NOI18N
		jbSchliessen.setText("Schließen"); // NOI18N
		jbSchliessen.setName("jbSchliessen"); // NOI18N
		jbSchliessen.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				jbSchliessenActionPerformed(evt);
			}
		});

		jbHilfe.setFont(resourceMap.getFont("jbSchliessen.font"));
		jbHilfe.setText("Hilfe");
		jbHilfe.setName("jbHilfe");
		jbHilfe.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				jbHilfeActionPerformed(evt);
			}
		});
		javax.swing.GroupLayout gl_jPanel2 = new javax.swing.GroupLayout(
				jPanel2);
		gl_jPanel2.setHorizontalGroup(gl_jPanel2.createParallelGroup(
				Alignment.TRAILING).addGroup(
				gl_jPanel2
						.createSequentialGroup()
						.addContainerGap(265, Short.MAX_VALUE)
						.addComponent(jbHilfe, GroupLayout.PREFERRED_SIZE, 84,
								GroupLayout.PREFERRED_SIZE).addGap(18)
						.addComponent(importiere).addGap(18)
						.addComponent(jbSchliessen).addGap(16)));
		gl_jPanel2.setVerticalGroup(gl_jPanel2.createParallelGroup(
				Alignment.TRAILING)
				.addGroup(
						gl_jPanel2
								.createSequentialGroup()
								.addContainerGap(GroupLayout.DEFAULT_SIZE,
										Short.MAX_VALUE)
								.addGroup(
										gl_jPanel2
												.createParallelGroup(
														Alignment.BASELINE)
												.addComponent(importiere)
												.addComponent(jbSchliessen)
												.addComponent(jbHilfe))
								.addContainerGap()));
		jPanel2.setLayout(gl_jPanel2);

		jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(null,
				resourceMap.getString("jPanel3.border.title"),
				javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
				javax.swing.border.TitledBorder.DEFAULT_POSITION,
				resourceMap.getFont("jPanel3.border.titleFont"))); // NOI18N
		jPanel3.setName("jPanel3"); // NOI18N

		jScrollPane1
				.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
		jScrollPane1.setName("jScrollPane1"); // NOI18N

		protokoll.setColumns(20);
		protokoll.setRows(5);
		protokoll.setName("protokoll"); // NOI18N
		jScrollPane1.setViewportView(protokoll);

		javax.swing.GroupLayout gl_jPanel3 = new javax.swing.GroupLayout(
				jPanel3);
		jPanel3.setLayout(gl_jPanel3);
		gl_jPanel3.setHorizontalGroup(gl_jPanel3.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGroup(
				gl_jPanel3
						.createSequentialGroup()
						.addContainerGap()
						.addComponent(jScrollPane1,
								javax.swing.GroupLayout.DEFAULT_SIZE, 554,
								Short.MAX_VALUE).addContainerGap()));
		gl_jPanel3.setVerticalGroup(gl_jPanel3.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGroup(
				gl_jPanel3
						.createSequentialGroup()
						.addComponent(jScrollPane1,
								javax.swing.GroupLayout.DEFAULT_SIZE, 275,
								Short.MAX_VALUE).addContainerGap()));

		jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder(null,
				"Durchführung",
				javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION,
				javax.swing.border.TitledBorder.DEFAULT_POSITION,
				resourceMap.getFont("jPanel4.border.titleFont"))); // NOI18N
		jPanel4.setName("jPanel4"); // NOI18N

		cbTestLauf.setForeground(resourceMap.getColor("cbTestLauf.foreground")); // NOI18N
		cbTestLauf.setSelected(true);
		cbTestLauf
				.setText("Testlauf: Es werden keine Änderungen durchgeführt."); // NOI18N
		cbTestLauf.setName("cbTestLauf"); // NOI18N

		javax.swing.GroupLayout gl_jPanel4 = new javax.swing.GroupLayout(
				jPanel4);
		jPanel4.setLayout(gl_jPanel4);
		gl_jPanel4.setHorizontalGroup(gl_jPanel4.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGroup(
				javax.swing.GroupLayout.Alignment.TRAILING,
				gl_jPanel4
						.createSequentialGroup()
						.addContainerGap()
						.addComponent(cbTestLauf,
								javax.swing.GroupLayout.DEFAULT_SIZE, 562,
								Short.MAX_VALUE).addContainerGap()));
		gl_jPanel4.setVerticalGroup(gl_jPanel4.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGroup(
				gl_jPanel4
						.createSequentialGroup()
						.addContainerGap()
						.addComponent(cbTestLauf)
						.addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE,
								Short.MAX_VALUE)));

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(
				getContentPane());
		layout.setHorizontalGroup(layout
				.createParallelGroup(Alignment.LEADING)
				.addGroup(
						layout.createSequentialGroup()
								.addContainerGap()
								.addGroup(
										layout.createParallelGroup(
												Alignment.LEADING)
												.addComponent(
														jPanel3,
														GroupLayout.DEFAULT_SIZE,
														GroupLayout.DEFAULT_SIZE,
														Short.MAX_VALUE)
												.addComponent(
														jPanel1,
														GroupLayout.DEFAULT_SIZE,
														GroupLayout.DEFAULT_SIZE,
														Short.MAX_VALUE)
												.addComponent(
														jPanel4,
														GroupLayout.DEFAULT_SIZE,
														GroupLayout.DEFAULT_SIZE,
														Short.MAX_VALUE)
												.addComponent(
														jPanel2,
														GroupLayout.DEFAULT_SIZE,
														GroupLayout.DEFAULT_SIZE,
														Short.MAX_VALUE))
								.addContainerGap()));
		layout.setVerticalGroup(layout.createParallelGroup(Alignment.LEADING)
				.addGroup(
						layout.createSequentialGroup()
								.addContainerGap()
								.addComponent(jPanel1,
										GroupLayout.PREFERRED_SIZE, 94,
										GroupLayout.PREFERRED_SIZE)
								.addPreferredGap(ComponentPlacement.RELATED)
								.addComponent(jPanel3,
										GroupLayout.DEFAULT_SIZE, 292,
										Short.MAX_VALUE)
								.addPreferredGap(ComponentPlacement.RELATED)
								.addComponent(jPanel4,
										GroupLayout.PREFERRED_SIZE,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.PREFERRED_SIZE)
								.addPreferredGap(ComponentPlacement.RELATED)
								.addComponent(jPanel2,
										GroupLayout.PREFERRED_SIZE,
										GroupLayout.DEFAULT_SIZE,
										GroupLayout.PREFERRED_SIZE).addGap(53)));
		getContentPane().setLayout(layout);

		pack();
	}// </editor-fold>//GEN-END:initComponents

	private void waehleActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_waehleActionPerformed
		JFileChooser importDatei = new JFileChooser();
		importDatei.setFileFilter(new FileNameExtensionFilter("TXT-Dateien",
				"txt"));
		importDatei.setCurrentDirectory(STANDARDDIR);
		if (importDatei.showOpenDialog(SchliessfachApp.getApplication()
				.getMainFrame()) == JFileChooser.APPROVE_OPTION) {
			File f = importDatei.getSelectedFile();
			if (!f.exists() || !f.canRead()) {
				JOptionPane
						.showMessageDialog(
								SchliessfachApp.getApplication().getMainFrame(),
								"Die Datei existiert nicht oder kann nicht gelesen werden.",
								"Öffnen", JOptionPane.INFORMATION_MESSAGE);
				return;
			}
			dateiName.setText(f.getAbsolutePath());
		}
	}// GEN-LAST:event_waehleActionPerformed

	private void importiereActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_importiereActionPerformed
		Task importLauf = new ImportTask(SchliessfachApp.getApplication());
		importLauf.addTaskListener(new TaskListener() {

			@Override
			public void doInBackground(TaskEvent event) {
				return;
			}

			@Override
			public void process(TaskEvent event) {
				return;
			}

			@Override
			public void succeeded(TaskEvent event) {
				// man darf nicht zweimal importieren!
				if (cbTestLauf.isSelected())
					importiere.setEnabled(true);
				jbSchliessen.setEnabled(true);
			}

			@Override
			public void failed(TaskEvent event) {
				importiere.setEnabled(true);
				jbSchliessen.setEnabled(true);
			}

			@Override
			public void cancelled(TaskEvent event) {
				importiere.setEnabled(true);
				jbSchliessen.setEnabled(true);
			}

			@Override
			public void interrupted(TaskEvent event) {
				return;
			}

			@Override
			public void finished(TaskEvent event) {
				// man darf nicht zweimal importieren!
				if (cbTestLauf.isSelected())
					importiere.setEnabled(true);
				jbSchliessen.setEnabled(true);
			}
		});
		SchliessfachApp.getApplication().getContext().getTaskService()
				.execute(importLauf);
		SchliessfachApp.getApplication().getContext().getTaskMonitor()
				.setForegroundTask(importLauf);
		importiere.setEnabled(false);
		jbSchliessen.setEnabled(false);
	}// GEN-LAST:event_importiereActionPerformed

	private void formWindowClosing(java.awt.event.WindowEvent evt) {// GEN-FIRST:event_formWindowClosing
		if (!jbSchliessen.isEnabled())
			return;
		dispose();
	}// GEN-LAST:event_formWindowClosing

	private void jbSchliessenActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_jbSchliessenActionPerformed
		dispose();
	}// GEN-LAST:event_jbSchliessenActionPerformed

	private void jbHilfeActionPerformed(java.awt.event.ActionEvent evt) {
		javax.swing.JOptionPane.showMessageDialog(this,
				resourceMap.getString("jbHilfe.text"));
	}

	/**
	 * @param args
	 *            the command line arguments
	 */
	public static void main(String args[]) {
		java.awt.EventQueue.invokeLater(new Runnable() {

			public void run() {
				SchuelerImportDlg dialog = new SchuelerImportDlg(
						new javax.swing.JFrame());
				dialog.addWindowListener(new java.awt.event.WindowAdapter() {

					public void windowClosing(java.awt.event.WindowEvent e) {
						System.exit(0);
					}
				});
				dialog.setVisible(true);
			}
		});
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JCheckBox cbTestLauf;
	private javax.swing.JTextField dateiName;
	private javax.swing.JButton importiere;
	private javax.swing.JPanel jPanel1;
	private javax.swing.JPanel jPanel2;
	private javax.swing.JPanel jPanel3;
	private javax.swing.JPanel jPanel4;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JButton jbSchliessen;
	private javax.swing.JButton jbHilfe;
	private javax.swing.JTextArea protokoll;
	private javax.swing.JButton waehle;
	private javax.swing.JComboBox zeichensatz;

	// End of variables declaration//GEN-END:variables

	private void protokollAddLine(String text) {
		protokoll.setText(protokoll.getText() + text + "\n");
	}

	@Action
	public void schliessen() {
		dispose();
	}

	private void importieren() {
		protokoll.setText("");
		File imf = new File(dateiName.getText());
		Map<Long, String[]> neu = new HashMap<Long, String[]>();
		Vector<Long> entfernt = new Vector<Long>();
		Vector<Long> gesperrt = new Vector<Long>();
		Map<Long, String[]> geaendert = new HashMap<Long, String[]>();
		try {
			// Importdatei einlesen
			protokoll.append(">>>> Die Importdatei " + dateiName.getText()
					+ " wird eingelesen <<<<\n");
			BufferedReader leseImF = new BufferedReader(new InputStreamReader(
					new FileInputStream(imf),
					(String) zeichensatz.getSelectedItem()));
			Vector<Long> importNr = new Vector<Long>();
			int zeile = 0;
			String s;
			Long nr = -1L;
			int index;
			// Dateiformat:
			// <Nummer>;<Nachname>;<Vorname>;<Geburtsdatum>;<Klasse>[;<Lehrer>]
			// in jeder gültigen Zeile
			while ((s = leseImF.readLine()) != null) {
				zeile++;
				String[] feld = s.split(";");
				if (feld != null && feld.length == 5) {
					// Kein Klassenlehrer!
					feld = Arrays.copyOf(feld, 6);
					feld[5] = "";
				}
				if (feld == null || feld.length != 6) {
					continue;
				}
				feld[feld.length - 1] = feld[feld.length - 1].trim();
				try {
					nr = Long.parseLong(feld[0]);
					if (schuelerMap.containsKey(nr)) {
						boolean aenderung = false;
						Schueler alt = schuelerMap.get(nr);
						aenderung = aenderung
								|| !alt.getKlasse().equals(feld[4])
								|| !alt.getLehrer().equals(feld[5]);
						aenderung = aenderung
								|| !alt.getNachName().equals(feld[1]);
						aenderung = aenderung
								|| !alt.getVorName().equals(feld[2]);
						aenderung = aenderung
								|| !alt.getGeburt().equals(
										Schueler.string2Date(feld[3]));
						aenderung = aenderung
								|| alt.getStatus() == SchuelerStatus.INAKTIV;
						if (aenderung) {
							geaendert.put(nr, feld);
						}
					} else {
						neu.put(nr, feld);
					}
					importNr.add(nr);
				} catch (NumberFormatException ex) {
					protokoll.append("Zeile(" + zeile
							+ "): Ungültiger Datensatz -- wird ignoriert.\n");
				} catch (ArrayIndexOutOfBoundsException ex) {
					protokoll.append("Zeile(" + zeile
							+ "): Ungültiger Datensatz -- wird ignoriert.\n");
				}
			}
			for (Long id : schuelerMap.keySet()) {
				if (!importNr.contains(id)
						&& schuelerMap.get(id).getStatus() != SchuelerStatus.INAKTIV) {
					entfernt.add(id);
				}
			}
			protokoll.append(geaendert.size() + " Schüler werden geändert.\n");
			protokoll.append(neu.size() + " Schüler werden hinzugefügt.\n");
			protokoll.append(entfernt.size() + " Schüler werden entfernt.\n");
			protokoll.append(">>>> Es wurden " + zeile
					+ " Zeilen aus der Importdatei eingelesen. <<<<\n");
		} catch (FileNotFoundException ex) {
			Logger.getLogger(SchuelerImportDlg.class.getName()).log(
					Level.SEVERE, null, ex);
			protokollAddLine("Die Import-Datei " + dateiName.getText()
					+ " kann nicht gelesen werden! -- Abbruch\n");
			return;
		} catch (IOException ex) {
			Logger.getLogger(SchuelerImportDlg.class.getName()).log(
					Level.SEVERE, null, ex);
			protokollAddLine("Die Import-Datei " + dateiName.getText()
					+ " kann nicht gelesen werden! -- Abbruch\n");
		}
		if (cbTestLauf.isSelected()) {
			protokoll
					.append(">>>> Testlauf: Es wurden keine Änderungen durchgeführt. <<<<");
			return;
		}
		// Durchführung der Änderungen
		// Änderungen
		protokoll.append(">>>> Es werden Schülerdaten geändert: <<<<\n");
		em.getTransaction().begin();
		Iterator<Long> aendern = geaendert.keySet().iterator();
		while (aendern.hasNext()) {
			Long nr = aendern.next();
			Schueler s1 = schuelerMap.get(nr);
			String[] f = geaendert.get(nr);
			protokoll.append(s1.getNr() + ": ");
			if (!s1.getNachName().equals(f[1]) || !s1.getVorName().equals(f[2])) {
				protokoll.append("[" + s1.getNachName() + "," + s1.getVorName()
						+ " --> " + f[1] + "," + f[2] + "]");
				s1.setNachName(f[1]);
				s1.setVorName(f[2]);
			}
			if (!s1.getGeburt().equals(Schueler.string2Date(f[3]))) {
				protokoll.append("[" + s1.getGeburtString() + " --> "
						+ Schueler.date2String(Schueler.string2Date(f[3]))
						+ "]");
				s1.setGeburt(Schueler.string2Date(f[3]));
			}
			if (!s1.getKlasse().equals(f[4]) || !s1.getLehrer().equals(f[5])) {
				protokoll.append("[" + s1.getKlasse() + "(" + s1.getLehrer()
						+ ") --> " + f[4] + "(" + f[5] + ")]");
				s1.setKlasse(f[4]);
				s1.setLehrer(f[5]);
			}
			if (s1.getStatus() == SchuelerStatus.INAKTIV) {
				protokoll.append("[" + s1.getStatus() + " --> "
						+ SchuelerStatus.AKTIV);
				s1.setStatus(SchuelerStatus.AKTIV);
			}
			protokoll.append("\n");
		}
		em.getTransaction().commit();

		// Entfernungen
		Iterator<Long> weg = entfernt.iterator();
		protokoll.append(">>>> Es werden " + entfernt.size()
				+ " Schüler entfernt: <<<<\n");
		em.getTransaction().begin();
		while (weg.hasNext()) {
			Schueler s = schuelerMap.get(weg.next());
			for (Vertrag v : s.getVertraege())
				if (v.getSchliessfach() == null && v.getEndeJahr() == null) {
					// noch offenen Vertrag automatisch abschließen
					v.setEndeJahr(SchliessfachApp.getApplication().heute
							.get(Calendar.YEAR));
				} else if (v.getSchliessfach() != null) {
					gesperrt.add(s.getId());
				}
			// offene Zahlungen ?
			Query q = em
					.createQuery("SELECT SUM(z.betrag) FROM Zahlung z JOIN z.vertrag v JOIN v.schueler s WHERE "
							+ Zahlungsart.mietenQS("s.nr=" + s.getNr()
									+ " AND z.art"));
			Double betrag = (Double) q.getSingleResult();
			if (betrag != null && betrag != 0.0)
				gesperrt.add(s.getId());
			// offene Kautionen ?
			q = em.createQuery("SELECT SUM(z.betrag) FROM Zahlung z JOIN z.vertrag v JOIN v.schueler s WHERE "
					+ Zahlungsart.kautionenQS("s.nr=" + s.getNr()
							+ " AND z.art"));
			betrag = (Double) q.getSingleResult();
			if (betrag != null && betrag != 0.0)
				gesperrt.add(s.getId());
			// löschen, falls er nicht gesperrt worden ist
			if (!gesperrt.contains(s.getId())) {
				s.setStatus(SchuelerStatus.INAKTIV);
				protokoll.append("Schüler [" + s.getNachName() + ","
						+ s.getVorName() + "] wird gelöscht.\n");
			} else {
				protokoll.append("-----> Schüler [" + s.getNachName() + ","
						+ s.getVorName() + "] ist gesperrt! <------ \n");
			}
		}
		em.getTransaction().commit();
		protokoll
				.append(">>>> ----------------------------------------------- <<<<\n");
		// Hinzufügungen
		Iterator<Long> hinzu = neu.keySet().iterator();
		protokoll.append(">>>> Es werden neue Schüler eingefugt: <<<<\n");
		em.getTransaction().begin();
		while (hinzu.hasNext()) {
			String[] f = neu.get(hinzu.next());
			Schueler s = new Schueler(Long.parseLong(f[0]), SchuelerStatus.NEU,
					f[1], f[2], f[3], f[4], f[5]);
			em.persist(s);
			protokoll.append("Schüler [" + f[1] + "," + f[2] + " Klasse["
					+ f[4] + " " + f[5] + "]] wird hinzugefügt.\n");

		}
		em.getTransaction().commit();
		protokoll
				.append(">>>> -------------------------------------------------- <<<<\n");
	}

	private class ImportTask extends Task {

		public ImportTask(Application application) {
			super(application);
			this.setTitle("Schülerdaten werden importiert...");
			this.setUserCanCancel(false);
		}

		@Override
		protected Object doInBackground() throws Exception {
			importieren();
			((SchliessfachView) SchliessfachApp.getApplication().getMainView())
					.aktualisiereKlassenliste();
			return null;
		}
	}
}
